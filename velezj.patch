diff -rupN nlopt-2.4.1/api/general.c nlopt-2.4.1.new/api/general.c
--- nlopt-2.4.1/api/general.c	2013-08-27 12:52:54.000000000 -0400
+++ nlopt-2.4.1.new/api/general.c	2014-03-10 13:45:37.252632590 -0400
@@ -139,3 +139,37 @@ void nlopt_srand_time_default(void) {
 }
 
 /*************************************************************************/
+
+char _error_file[255] ;
+char _error_reason[255];
+int _error_line;
+nlopt_result _error_result;
+
+void nlopt_last_error_info( nlopt_result* res,
+			    char* reason,
+			    int* line,
+			    char* file )
+{
+  *res = _error_result;
+  *line = _error_line;
+  snprintf( reason, 255, "%s", _error_reason );
+  snprintf( file, 255, "%s", _error_file );
+}
+
+void nlopt_set_error_info( nlopt_result res,
+			   char* reason,
+			   int line,
+			   char* file )
+{
+  _error_result = res;
+  _error_line = line;
+  snprintf( _error_reason, 255, "~s", reason ); 
+  snprintf( _error_file, 255, "~s", file );
+  printf( "**nlopt-error-set: %s (no:%d %s:%d)",
+	  _error_reason,
+	  _error_result,
+	  _error_file,
+	  _error_line);
+}
+
+/*************************************************************************/
diff -rupN nlopt-2.4.1/api/nlopt.h nlopt-2.4.1.new/api/nlopt.h
--- nlopt-2.4.1/api/nlopt.h	2013-11-19 15:21:57.000000000 -0500
+++ nlopt-2.4.1.new/api/nlopt.h	2014-03-10 14:21:17.068012893 -0400
@@ -177,6 +177,31 @@ NLOPT_EXTERN(void) nlopt_srand_time(void
 
 NLOPT_EXTERN(void) nlopt_version(int *major, int *minor, int *bugfix);
 
+void nlopt_set_error_info( nlopt_result res,
+			   char* reason,
+			   int line,
+			   char* file );
+void nlopt_last_error_info( nlopt_result* res,
+			    char* reason,
+			    int* line,
+			    char* file );
+
+#define RETURN_NLOPT_ERR( err, reason )				\
+  do {								\
+  nlopt_set_error_info( err, reason, __LINE__, __FILE__ );	\
+  return err;							\
+  } while(0)
+
+#define NLOPT_ERR( store, err, reason )				\
+  do {								\
+  nlopt_set_error_info( err, reason, __LINE__, __FILE__ );	\
+  store = err;							\
+  } while(0)
+
+
+  
+
+
 /*************************** OBJECT-ORIENTED API **************************/
 /* The style here is that we create an nlopt_opt "object" (an opaque pointer),
    then set various optimization parameters, and then execute the
diff -rupN nlopt-2.4.1/bobyqa/bobyqa.c nlopt-2.4.1.new/bobyqa/bobyqa.c
--- nlopt-2.4.1/bobyqa/bobyqa.c	2013-03-28 10:29:04.000000000 -0400
+++ nlopt-2.4.1.new/bobyqa/bobyqa.c	2014-03-10 14:09:39.630044516 -0400
@@ -681,7 +681,7 @@ L260:
 	if (f < fval[*kopt]) {
 	    *kopt = kpt;
 	}
-	if (nlopt_stop_forced(stop)) return NLOPT_FORCED_STOP;
+	if (nlopt_stop_forced(stop)) RETURN_NLOPT_ERR( NLOPT_FORCED_STOP, "forced!");
 	else if (f < stop->minf_max) return NLOPT_MINF_MAX_REACHED;
 	else if (nlopt_stop_evals(stop)) return NLOPT_MAXEVAL_REACHED;
 	else if (nlopt_stop_time(stop)) return NLOPT_MAXTIME_REACHED;
@@ -1941,7 +1941,7 @@ L50:
 	temp = xpt[nf + ipt * xpt_dim1] * xpt[nf + jpt * xpt_dim1];
 	hq[ih] = (fbeg - fval[ipt + 1] - fval[jpt + 1] + f) / temp;
     }
-    if (nlopt_stop_forced(stop)) return NLOPT_FORCED_STOP;
+    if (nlopt_stop_forced(stop)) RETURN_NLOPT_ERR( NLOPT_FORCED_STOP, "forced!");
     else if (f < stop->minf_max) return NLOPT_MINF_MAX_REACHED;
     else if (nlopt_stop_evals(stop)) return NLOPT_MAXEVAL_REACHED;
     else if (nlopt_stop_time(stop)) return NLOPT_MAXTIME_REACHED;
@@ -2482,7 +2482,7 @@ L230:
 	    }
 	    /* Return from BOBYQA because of much cancellation in a
 	       denominator. */
-	    rc = NLOPT_ROUNDOFF_LIMITED;
+	    NLOPT_ERR(rc , NLOPT_ROUNDOFF_LIMITED, "roundoff: denom <= half * (d_1 * d_1)");
 	    goto L720;
 	}
 
@@ -2545,7 +2545,7 @@ L350:
 	    }
 	    /* Return from BOBYQA because of much cancellation in a
 	       denominator. */
-	    rc = NLOPT_ROUNDOFF_LIMITED;
+	    NLOPT_ERR(rc , NLOPT_ROUNDOFF_LIMITED, "roundoff: scaden <= half * biglsq" );
 	    goto L720;
 	}
     }
@@ -2574,7 +2574,7 @@ L360:
 /* L380: */
     }
 
-    if (nlopt_stop_forced(stop)) rc = NLOPT_FORCED_STOP;
+    if (nlopt_stop_forced(stop)) NLOPT_ERR(rc , NLOPT_FORCED_STOP, "forced!");
     else if (nlopt_stop_evals(stop)) rc = NLOPT_MAXEVAL_REACHED;
     else if (nlopt_stop_time(stop)) rc = NLOPT_MAXTIME_REACHED;
     if (rc != NLOPT_SUCCESS) goto L720;
@@ -2634,7 +2634,7 @@ L360:
 	if (vquad >= zero) {
 	  /* Return from BOBYQA because a trust region step has failed
 	     to reduce Q. */
-	  rc = NLOPT_ROUNDOFF_LIMITED; /* or FTOL_REACHED? */
+	  NLOPT_ERR( rc , NLOPT_ROUNDOFF_LIMITED, "roudoff (maybe!): vquad >= 0"); /* or FTOL_REACHED? */
 	  goto L720;
 	}
 	ratio = (f - fopt) / vquad;
@@ -3095,7 +3095,7 @@ nlopt_result bobyqa(int n, int npt, doub
     /* SGJ 2010: rescale parameters to make the initial step sizes dx
                  equal in all directions */
     s = nlopt_compute_rescaling(U(n), dx);
-    if (!s) return NLOPT_OUT_OF_MEMORY;
+    if (!s) RETURN_NLOPT_ERR( NLOPT_OUT_OF_MEMORY, "mem!");
 
     /* this statement must go before goto done, so that --x occurs */
     nlopt_rescale(U(n), s, x, x); --x;
@@ -3103,10 +3103,10 @@ nlopt_result bobyqa(int n, int npt, doub
     xs = (double *) malloc(sizeof(double) * (U(n)));
 
     sxl = nlopt_new_rescaled(U(n), s, xl);
-    if (!sxl) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+    if (!sxl) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
     xl = sxl;
     sxu = nlopt_new_rescaled(U(n), s, xu);
-    if (!sxu) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+    if (!sxu) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
     xu = sxu;
     nlopt_reorder_bounds(n, sxl, sxu);
 
@@ -3197,7 +3197,7 @@ nlopt_result bobyqa(int n, int npt, doub
     iw = ivl + ndim;
 
     w0 = (double *) malloc(sizeof(double) * U((npt+5)*(npt+n)+3*n*(n+5)/2));
-    if (!w0) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+    if (!w0) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
     w = w0 - 1;
 
 /*   Return if there is insufficient space between the bounds. Modify the */
@@ -3214,7 +3214,7 @@ nlopt_result bobyqa(int n, int npt, doub
 	if (temp < rhobeg + rhobeg) {
 	  /* Return from BOBYQA because one of the differences
 	     XU(I)-XL(I)s is less than 2*RHOBEG. */
-	     ret = NLOPT_INVALID_ARGS;
+	  NLOPT_ERR(ret , NLOPT_INVALID_ARGS, "bobyqa: xu[j] - xl[j] < rhobeg^2 :: insufficient space between bounds need to create the first quadratic model.");
 	     goto done;
 	}
 	jsl = isl + j - 1;
diff -rupN nlopt-2.4.1/cobyla/cobyla.c nlopt-2.4.1.new/cobyla/cobyla.c
--- nlopt-2.4.1/cobyla/cobyla.c	2013-03-28 10:29:04.000000000 -0400
+++ nlopt-2.4.1.new/cobyla/cobyla.c	2014-03-10 14:16:16.970561127 -0400
@@ -197,16 +197,16 @@ nlopt_result cobyla_minimize(unsigned n,
      s.lb = s.ub = s.xtmp = s.con_tol = s.scale = NULL;
 
      s.scale = nlopt_compute_rescaling(n, dx);
-     if (!s.scale) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (!s.scale) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 
      s.lb = nlopt_new_rescaled(n, s.scale, lb);
-     if (!s.lb) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (!s.lb) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
      s.ub = nlopt_new_rescaled(n, s.scale, ub);
-     if (!s.ub) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (!s.ub) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
      nlopt_reorder_bounds(n, s.lb, s.ub);
 
      s.xtmp = (double *) malloc(sizeof(double) * n);
-     if (!s.xtmp) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (!s.xtmp) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 
      /* SGJ, 2008: compute rhoend from NLopt stop info */
      rhobeg = fabs(dx[0] / s.scale[0]);
@@ -227,7 +227,7 @@ nlopt_result cobyla_minimize(unsigned n,
      }
 
      s.con_tol = (double *) malloc(sizeof(double) * m);
-     if (m && !s.con_tol) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (m && !s.con_tol) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 
      for (j = 0; j < m; ++j) s.con_tol[j] = 0;
      for (j = i = 0; i < s.m_orig; ++i) {
@@ -389,7 +389,7 @@ nlopt_result cobyla(int n, int m, double
   if (n < 0 || m < 0)
   {
     if (iprint>=1) fprintf(stderr, "cobyla: N<0 or M<0.\n");
-    return NLOPT_INVALID_ARGS;
+    RETURN_NLOPT_ERR( NLOPT_INVALID_ARGS, "cobyla: N<0 or M<0" );
   }
 
   /* workspace allocation */
@@ -397,14 +397,14 @@ nlopt_result cobyla(int n, int m, double
   if (w == NULL)
   {
     if (iprint>=1) fprintf(stderr, "cobyla: memory allocation error.\n");
-    return NLOPT_OUT_OF_MEMORY;
+    RETURN_NLOPT_ERR( NLOPT_OUT_OF_MEMORY, "mem!" );
   }
   iact = (int*)malloc(U(m+1)*sizeof(*iact));
   if (iact == NULL)
   {
     if (iprint>=1) fprintf(stderr, "cobyla: memory allocation error.\n");
     free(w);
-    return NLOPT_OUT_OF_MEMORY;
+    RETURN_NLOPT_ERR( NLOPT_OUT_OF_MEMORY, "mem!");
   }
   
   /* Parameter adjustments */
@@ -562,7 +562,7 @@ static nlopt_result cobylb(int *n, int *
      #*&!%*@ Fortran-66 spaghetti code */
 
 L40:
-  if (nlopt_stop_forced(stop)) rc = NLOPT_FORCED_STOP;
+  if (nlopt_stop_forced(stop)) NLOPT_ERR(rc , NLOPT_FORCED_STOP, "forced!");
   else if (stop->nevals > 0) {
        if (nlopt_stop_evals(stop)) rc = NLOPT_MAXEVAL_REACHED;
        else if (nlopt_stop_time(stop)) rc = NLOPT_MAXTIME_REACHED;
@@ -575,7 +575,7 @@ L40:
     if (*iprint >= 1) {
       fprintf(stderr, "cobyla: user requested end of minimization.\n");
     }
-    rc = NLOPT_FORCED_STOP;
+    NLOPT_ERR(rc , NLOPT_FORCED_STOP, "forced!");
     goto L600;
   }
 
@@ -747,7 +747,7 @@ L140:
     if (*iprint >= 1) {
       fprintf(stderr, "cobyla: rounding errors are becoming damaging.\n");
     }
-    rc = NLOPT_ROUNDOFF_LIMITED;
+    NLOPT_ERR(rc , NLOPT_ROUNDOFF_LIMITED, "roundoff cobyla: error > .1" );
     goto L600;
   }
 
@@ -1193,8 +1193,13 @@ L550:
     }
     goto L140;
   }
-  else /* rho <= rhoend */
-       rc = rhoend > 0 ? NLOPT_XTOL_REACHED : NLOPT_ROUNDOFF_LIMITED;
+  else /* rho <= rhoend */ {
+    if( rhoend > 0 ) {
+      rc = NLOPT_XTOL_REACHED;
+    } else {
+      NLOPT_ERR( rc,  NLOPT_ROUNDOFF_LIMITED, "roundoff cobyla: rho < rhoend && rhoend <= 0" );
+    } 
+  }
 
 /* Return the best calculated values of the variables. */
 
@@ -1710,7 +1715,7 @@ L340:
   }
 
   /* SGJ, 2010: check for error here */
-  if (nlopt_isinf(step)) return NLOPT_ROUNDOFF_LIMITED;
+  if (nlopt_isinf(step)) RETURN_NLOPT_ERR( NLOPT_ROUNDOFF_LIMITED, "roundoff cobyla: isinf(step)" );
 
 /* Set DXNEW to the new variables if STEP is the steplength, and reduce */
 /* RESMAX to the corresponding maximum residual if stage one is being done. */
diff -rupN nlopt-2.4.1/mlsl/mlsl.c nlopt-2.4.1.new/mlsl/mlsl.c
--- nlopt-2.4.1/mlsl/mlsl.c	2013-03-28 10:29:05.000000000 -0400
+++ nlopt-2.4.1.new/mlsl/mlsl.c	2014-03-10 14:02:46.937041486 -0400
@@ -292,7 +292,7 @@ nlopt_result mlsl_minimize(int n, nlopt_
 	  d.N = 4; /* FIXME: what is good number of samples per iteration? */
      else
 	  d.N = Nsamples;
-     if (d.N < 1) return NLOPT_INVALID_ARGS;
+     if (d.N < 1) RETURN_NLOPT_ERR( NLOPT_INVALID_ARGS, "bad sampler per iteration: d.N < 1" );
 
      d.n = n;
      d.lb = lb; d.ub = ub;
@@ -323,7 +323,7 @@ nlopt_result mlsl_minimize(int n, nlopt_
      
 
      p = alloc_pt(n);
-     if (!p) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+     if (!p) { NLOPT_ERR(ret, NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 
      /* FIXME: how many sobol points to skip, if any? */
      nlopt_sobol_skip(d.s, (unsigned) (10*n+d.N), p->x);
@@ -332,9 +332,9 @@ nlopt_result mlsl_minimize(int n, nlopt_
      p->f = f(n, x, NULL, f_data);
      stop->nevals++;
      if (!rb_tree_insert(&d.pts, (rb_key) p)) { 
-	  free(p); ret = NLOPT_OUT_OF_MEMORY; 
+       free(p); NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); 
      }
-     if (nlopt_stop_forced(stop)) ret = NLOPT_FORCED_STOP;
+     if (nlopt_stop_forced(stop)) NLOPT_ERR(ret , NLOPT_FORCED_STOP, "forced!");
      else if (nlopt_stop_evals(stop)) ret = NLOPT_MAXEVAL_REACHED;
      else if (nlopt_stop_time(stop)) ret = NLOPT_MAXTIME_REACHED;
      else if (p->f < stop->minf_max) ret = NLOPT_MINF_MAX_REACHED;
@@ -348,7 +348,7 @@ nlopt_result mlsl_minimize(int n, nlopt_
 	  /* sampling phase: add random/quasi-random points */
 	  for (i = 0; i < d.N && ret == NLOPT_SUCCESS; ++i) {
 	       p = alloc_pt(n);
-	       if (!p) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+	       if (!p) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 	       if (d.s) nlopt_sobol_next(d.s, p->x, lb, ub);
 	       else { /* use random points instead of LDS */
 		    int j;
@@ -357,9 +357,9 @@ nlopt_result mlsl_minimize(int n, nlopt_
 	       p->f = f(n, p->x, NULL, f_data);
 	       stop->nevals++;
 	       if (!rb_tree_insert(&d.pts, (rb_key) p)) { 
-		    free(p); ret = NLOPT_OUT_OF_MEMORY;
+		 free(p); NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!");
 	       }
-	       if (nlopt_stop_forced(stop)) ret = NLOPT_FORCED_STOP;
+	       if (nlopt_stop_forced(stop)) NLOPT_ERR(ret , NLOPT_FORCED_STOP, "forced!");
 	       else if (nlopt_stop_evals(stop)) ret = NLOPT_MAXEVAL_REACHED;
 	       else if (nlopt_stop_time(stop)) ret = NLOPT_MAXTIME_REACHED;
 	       else if (p->f < stop->minf_max) ret = NLOPT_MINF_MAX_REACHED;
@@ -386,7 +386,7 @@ nlopt_result mlsl_minimize(int n, nlopt_
 		    double t = nlopt_seconds();
 
 		    if (nlopt_stop_forced(stop)) {
-			 ret = NLOPT_FORCED_STOP; break;
+		      NLOPT_ERR(ret , NLOPT_FORCED_STOP, "forced!"); break;
 		    }
 		    if (nlopt_stop_evals(stop)) {
                          ret = NLOPT_MAXEVAL_REACHED; break;
@@ -396,7 +396,7 @@ nlopt_result mlsl_minimize(int n, nlopt_
 			 ret = NLOPT_MAXTIME_REACHED; break;
 		    }
 		    lm = (double *) malloc(sizeof(double) * (n+1));
-		    if (!lm) { ret = NLOPT_OUT_OF_MEMORY; goto done; }
+		    if (!lm) { NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!"); goto done; }
 		    memcpy(lm+1, p->x, sizeof(double) * n);
 		    lret = nlopt_optimize_limited(local_opt, lm+1, lm,
 						  stop->maxeval - stop->nevals,
@@ -405,9 +405,9 @@ nlopt_result mlsl_minimize(int n, nlopt_
 		    p->minimized = 1;
 		    if (lret < 0) { free(lm); ret = lret; goto done; }
 		    if (!rb_tree_insert(&d.lms, lm)) { 
-			 free(lm); ret = NLOPT_OUT_OF_MEMORY;
+		      free(lm); NLOPT_ERR(ret , NLOPT_OUT_OF_MEMORY, "mem!");
 		    }
-		    else if (nlopt_stop_forced(stop)) ret = NLOPT_FORCED_STOP;
+		    else if (nlopt_stop_forced(stop)) NLOPT_ERR(ret , NLOPT_FORCED_STOP, "forced!");
 		    else if (*lm < stop->minf_max) 
 			 ret = NLOPT_MINF_MAX_REACHED;
 		    else if (nlopt_stop_evals(stop))
